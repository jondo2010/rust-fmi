# FMI Export Architecture

## Overview

The FMI export system enables creating Functional Mockup Units (FMUs) from Rust code using an explicit, clean architecture. Users declare their model structure explicitly and implement physics equations in a simple trait.

### Core Design Pattern

The user defines a model struct with state variables and their corresponding derivative fields.

```rust
#[derive(FmuModel, Default, Debug)]
#[model(model_exchange())]
struct VanDerPol {
    // Parameters
    #[variable(causality = Parameter, start = 1.0)]
    mu: f64,

    // State variables
    #[variable(causality = Output, state, start = 2.0)]
    x0: f64,

    #[variable(causality = Local, state, start = 0.0)]
    x1: f64,

    // Derivative fields
    #[variable(causality = Local, derivative_of = x0, start = 0.0)]
    der_x0: f64,

    #[variable(causality = Local, derivative_of = x1, start = 0.0)]
    der_x1: f64,
}

// The user implements some trait(s) to define the model behavior.
impl UserModel for VanDerPol {
    fn calculate_values(&mut self) -> fmi::fmi3::Fmi3Status {
        // Access both state variables and derivative fields directly
        self.der_x0 = self.x1;
        self.der_x1 = self.mu * ((1.0 - self.x0 * self.x0) * self.x1) - self.x0;
        fmi::fmi3::Fmi3Res::OK.into()
    }
}

// The export_fmu macro generates the necessary FMI interface implementations. The generated code
// delegates to UserModel and other traits as needed.
fmi_export::export_fmu!(VanDerPol);
```

## Architecture Specification

### Layers and Wrapper Traits

1. The user-defined model struct implements the `UserModel` trait to define the physics behavior.
2. The user code invokes the `export_fmu!` macro to generate the FMI interface.
3. The `export_fmu` macro expands to implementations of the full FMI3 interface functions (declared extern "C" functions).
4. Each exported function delegates to a wrapper method defined in the `Fmi3Common`, `Fmi3ModelExchange`, or `Fmi3CoSimulation` traits. These trait methods are 'low-level'. Their arguments and return types match the FMI specification exactly.

Example call flow:
```
1. fmi3GetFloat()                                       [extern "C" function]
2.   <UserModel as Fmi3Common>::get_float()             [generated by export_fmu!]
3.     <ModelInstance<Self> as GetSet>::get_float()     [default trait impl in wrappers.rs]
4.       get_float()                                    [recursively implemented by the FmuModel derive macro]
```

## Desired FMU export cases

| Case | ME | CS | SE | ModelDescription | Notes |
|------|----|----|----|------------------|---------------------------------------------------------------------------------|
| 1    | ✓  | x  | x  | ME only          | Default case                                                                    |
| 2    | x  | ✓  | x  | CS only          | User-implemented doStep(). ME functions still generated but inactive            |
| 3    | ✓  | ✓  | x  | ME + CS          | User-implemented doStep(). User provides both ME physics and CS stepping logic  |
| 4    | ✓  | ✓  | x  | ME + CS          | Embedded solver wrapping ME. CS automatically wraps ME with internal solver     |
| 5    | x  | x  | ✓  | SE only          | Future work                                                                     |

## Additional requirements

1. At runtime, the FMU instance can only be one of ME, CS or SE. Calls to functions unsupported for that instance type must return error codes as per the FMI specification.
2. The additional state required for the embedded CS solver must be stored within the FMU instance. The user model struct must not be required to store this additional state (it should be hidden from the user).
