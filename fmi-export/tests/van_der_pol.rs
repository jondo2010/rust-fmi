use fmi::fmi3::{Fmi3Res, Common, ModelExchange};
use fmi_export::{FmuModel, fmi3::{Model, UserModel}};

/// Van Der Pol oscillator model
///
/// This model implements the classic Van Der Pol oscillator, a non-conservative oscillator
/// with non-linear damping. The model exhibits self-sustained oscillations with a limit cycle.
/// 
/// Mathematical equations:
/// - dx0/dt = x1
/// - dx1/dt = mu * (1 - x0^2) * x1 - x0
/// 
/// where:
/// - x0: position variable (state)
/// - x1: velocity variable (state)  
/// - mu: damping parameter (mu > 0 for self-oscillation)
#[derive(FmuModel, Default, Debug)]
#[model(ModelExchange)]
struct VanDerPol {
    /// Damping parameter (input parameter)
    #[variable(causality = parameter, start = 1.0)]
    mu: f64,

    /// Position variable (state output)
    #[variable(causality = output, state = true, start = 2.0)]
    x0: f64,

    /// Velocity variable (state output)
    #[variable(causality = local, state = true, start = 0.0)]
    x1: f64,
    
    // TEMPORARY: Manual derivative fields until procedural macro supports automatic field injection
    /// Derivative of position (automatically generated by macro in the future)
    #[variable(causality = local, derivative_of = "x0", start = 0.0)]
    der_x0: f64,

    /// Derivative of velocity (automatically generated by macro in the future)
    #[variable(causality = local, derivative_of = "x1", start = 0.0)]
    der_x1: f64,
}

impl UserModel for VanDerPol {
    /// Calculate Van Der Pol derivatives and store them in the automatically generated derivative fields
    fn calculate_values(&mut self) -> fmi::fmi3::Fmi3Status {
        // Get current state values
        let x0 = self.x0;
        let x1 = self.x1;
        let mu = self.mu;

        // Calculate derivatives using Van Der Pol equations and store in derivative fields
        // These derivative fields (der_x0, der_x1) are automatically generated by the macro
        self.der_x0 = x1;
        self.der_x1 = mu * ((1.0 - x0 * x0) * x1) - x0;

        Fmi3Res::OK.into()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use fmi_export::fmi3::ModelInstance;
    
    #[test]
    fn test_model_metadata() {
        // Test that the Model derive macro generates the expected metadata
        assert_eq!(VanDerPol::MODEL_NAME, "VanDerPol");
        assert!(!VanDerPol::MODEL_DESCRIPTION.is_empty());
        assert!(!VanDerPol::INSTANTIATION_TOKEN.is_empty());
        
        // Debug: Print actual state count to see what's happening
        let actual_state_count = VanDerPol::get_number_of_continuous_states();
        println!("Actual continuous states count: {}", actual_state_count);
        
        // Test continuous states count (x0 and x1 are states)
        // If this fails, the state attributes aren't being parsed correctly
        assert_eq!(actual_state_count, 2, "Expected 2 continuous states (x0 and x1), got {}", actual_state_count);
        
        // Test model description content
        assert!(VanDerPol::MODEL_DESCRIPTION.contains("Van Der Pol oscillator"));
    }

    #[test]
    fn test_calculate_values() {
        let mut model = VanDerPol::default();
        
        // Set initial conditions
        model.x0 = 1.0;
        model.x1 = 0.0;
        model.mu = 1.0;
        
        // Calculate derivatives
        let status = model.calculate_values();
        let expected_status = fmi::fmi3::Fmi3Status::from(fmi::fmi3::Fmi3Res::OK);
        assert_eq!(format!("{:?}", status), format!("{:?}", expected_status));
        
        // Check that derivatives were calculated correctly and stored in the generated fields
        assert_eq!(model.der_x0, 0.0); // der_x0 = x1 = 0.0
        assert_eq!(model.der_x1, -1.0); // der_x1 = mu * ((1 - x0²) * x1) - x0 = 1 * ((1 - 1) * 0) - 1 = -1
    }

    #[test]
    fn test_derivative_field_access() {
        let mut model = VanDerPol::default();
        
        // Set test values
        model.x0 = 2.0;
        model.x1 = 1.5;
        model.mu = 0.5;
        
        // Calculate derivatives
        model.calculate_values();
        
        // Test that derivative fields contain calculated values
        assert_eq!(model.der_x0, 1.5);
        
        // der_x1 = mu * ((1 - x0²) * x1) - x0
        //         = 0.5 * ((1 - 4) * 1.5) - 2
        //         = 0.5 * (-3 * 1.5) - 2
        //         = 0.5 * (-4.5) - 2
        //         = -2.25 - 2 = -4.25
        assert_eq!(model.der_x1, -4.25);
    }

    #[test]
    fn test_model_exchange_interface() {
        let instantiation_token = VanDerPol::INSTANTIATION_TOKEN;
        
        let mut instance = ModelInstance::<VanDerPol>::new(
            "TestModel".to_string(),
            std::path::PathBuf::from("/tmp"),
            false,
            None,
            instantiation_token,
        ).expect("Failed to create model instance");

        // Enter initialization mode
        instance.enter_initialization_mode(None, 0.0, None).expect("Failed to enter initialization mode");
        
        // Set and get continuous states
        let initial_states = [2.0, 0.0]; // x0=2.0, x1=0.0
        instance.set_continuous_states(&initial_states).expect("Failed to set states");
        
        let mut retrieved_states = [0.0, 0.0];
        instance.get_continuous_states(&mut retrieved_states).expect("Failed to get states");
        assert_eq!(retrieved_states, [2.0, 0.0]);
        
        // Exit initialization and enter continuous time mode
        instance.exit_initialization_mode().expect("Failed to exit initialization mode");
        instance.enter_event_mode().expect("Failed to enter event mode");
        instance.enter_continuous_time_mode().expect("Failed to enter continuous time mode");
        
        // Get derivatives
        let mut derivatives = [0.0, 0.0];
        instance.get_continuous_state_derivatives(&mut derivatives).expect("Failed to get derivatives");
        
        // Verify calculated derivatives
        assert_eq!(derivatives[0], 0.0);   // der_x0 = x1 = 0.0
        assert_eq!(derivatives[1], -2.0);  // der_x1 = mu * (1 - x0^2) * x1 - x0 = 1 * (1 - 4) * 0 - 2 = -2.0
    }
}
